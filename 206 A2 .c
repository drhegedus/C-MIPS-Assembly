/* FILE: A2_bmp_helpers.c is where you will code your answers for Assignment 2. *  * Each of the functions below can be considered a start for you.  * * You should leave all of the code as is, except for what's surrounded * in comments like "REPLACE EVERTHING FROM HERE... TO HERE. * * The assignment document and the header A2_bmp_headers.h should help * to find out how to complete and test the functions. Good luck! * */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <assert.h>int bmp_open( char* bmp_filename,        unsigned int *width,               unsigned int *height,      unsigned int *bits_per_pixel,               unsigned int *padding,     unsigned int *data_size,               unsigned int *data_offset, unsigned char** img_data ){              		FILE *bmpfile = fopen(bmp_filename, "rb");	char b, m;	if (fread (&b,1,1,bmpfile) != 1) {		exit (-1);	} else if (fread (&m,1,1,bmpfile) != 1) {		exit (-1);	}		if (b != 'B' || m != 'M') {		printf("The file is not the right type");		exit (-1);	}		if (fread(data_size, sizeof(unsigned int), 1, bmpfile) != 1){		exit (-1);	}	fclose(bmpfile);	bmpfile = fopen(bmp_filename, "rb");	unsigned char* imageData;	imageData = (unsigned char*)malloc((*data_size)*(sizeof(unsigned char)));			fread(imageData, 1, *data_size, bmpfile);	*img_data = imageData;	img_data = &imageData;	*data_offset = *(unsigned int*)(imageData + 10);	*width = *(unsigned int*)(imageData + 18);	*height = *(unsigned int*)(imageData + 22);	*bits_per_pixel = *(unsigned int*)(imageData + 28);		if ((((*bits_per_pixel)/8)%4) == 0) {		*padding = 0;	} else{		while (((((*bits_per_pixel)/8)*(*width) + (*padding))%4) != 0) {			(*padding) ++;		}	}	return 0;  }// We've implemented bmp_close for you. No need to modify this functionvoid bmp_close( unsigned char **img_data ){  if( *img_data != NULL ){    free( *img_data );    *img_data = NULL;  }}int bmp_mask( char* input_bmp_filename, char* output_bmp_filename,               unsigned int x_min, unsigned int y_min, unsigned int x_max, unsigned int y_max,              unsigned char red, unsigned char green, unsigned char blue ){	unsigned int img_width;	unsigned int img_height;	unsigned int bits_per_pixel;	unsigned int data_size;	unsigned int padding;	unsigned int data_offset;	unsigned char* img_data    = NULL;  	int open_return_code = bmp_open( input_bmp_filename, &img_width, &img_height, &bits_per_pixel, &padding, &data_size, &data_offset, &img_data );   	if( open_return_code ){ printf( "bmp_open failed. Returning from bmp_mask without attempting changes.\n" ); return -1; }	unsigned char masked_data[data_size];    	memcpy(masked_data, img_data, data_size);    	for (int i = y_min; i < y_max; i++) {        	for (int j = x_min; j < x_max; j++) {			unsigned int start = img_width*(i - 1) + j;            		unsigned int RGB = data_offset + (start)*((bits_per_pixel)/8);              		masked_data[RGB] = red;            		masked_data[RGB + 1] = green;            		masked_data[RGB + 2] = blue;       		}   	 }        	FILE *maskedFile;   	maskedFile = fopen(output_bmp_filename, "wb");    	fwrite(masked_data, 1, data_size, maskedFile);    	fclose(maskedFile);		bmp_close( &img_data );  	return 0;}         int bmp_collage( char* bmp_input1, char* bmp_input2, char* bmp_result, int x_offset, int y_offset ){	unsigned int img_width1;	unsigned int img_height1;	unsigned int bits_per_pixel1;	unsigned int data_size1;	unsigned int padding1;	unsigned int data_offset1;	unsigned char* img_data1    = NULL;  	int open_return_code = bmp_open( bmp_input1, &img_width1, &img_height1, &bits_per_pixel1, &padding1, &data_size1, &data_offset1, &img_data1 ); 	if( open_return_code ){ printf( "bmp_open failed for %s. Returning from bmp_collage without attempting changes.\n", bmp_input1 ); return -1; }  	unsigned int img_width2;	unsigned int img_height2;	unsigned int bits_per_pixel2;	unsigned int data_size2;	unsigned int padding2;	unsigned int data_offset2;	unsigned char* img_data2    = NULL;  	open_return_code = bmp_open( bmp_input2, &img_width2, &img_height2, &bits_per_pixel2, &padding2, &data_size2, &data_offset2, &img_data2 );   	if( open_return_code ){ printf( "bmp_open failed for %s. Returning from bmp_collage without attempting changes.\n", bmp_input2 ); return -1; }  	//COMPUTING NEW SIZE:	unsigned int new_width;	unsigned int new_height;	unsigned int new_padding;	if (x_offset + img_width2 < img_width1) {		new_width = img_width1;	} else {		if ((x_offset+img_width2)%4 == 0) {			new_width = img_width2 + x_offset;		} else {			new_padding = (x_offset+img_width2)%4;			printf("New Padding: %d\n", new_padding);			printf("Padding: %d\n", padding2);			new_width = img_width2 + x_offset + padding2;		}	}	//SINCE THERE CAN BE A NEGATIVE Y OFFSET, NEED TO MANAGE THIS 	if (y_offset < 0) {		new_height = (y_offset * -1) + img_height1;	}	else if (y_offset + img_height2 < img_height1) {		new_height = img_height1;	} else {		new_height = img_height2 + y_offset;	}		//COMPUTING NEW BPP:	unsigned int new_bpp;	if (bits_per_pixel1 >= bits_per_pixel2) {		new_bpp = bits_per_pixel1;	} else {		new_bpp = bits_per_pixel2;	}	//COMPUTING NEW DATA_SIZE AND NEW_DATA_OFFSET:	unsigned int new_data_size;	unsigned int new_data_offset;	new_data_offset = data_offset1;	new_data_size = new_data_offset + (new_bpp*(new_width)*new_height);			//ALLOCATING NEW MEM and COPYING HEADER:	unsigned char* new_img;	new_img = (unsigned char*) malloc(new_data_size*(sizeof(unsigned char)));	//memset(new_img, 255, new_data_size*(sizeof(unsigned char)));  NOT NEEDED	//memcpy(new_img, img_data1, data_size1);	//UPDATED RELEVANT FIELDS:	memcpy(new_img, img_data1, new_data_offset);	memcpy((new_img+18), &new_width, sizeof(new_width));	memcpy((new_img+22), &new_height, sizeof(new_height));	memcpy((new_img+2), &new_data_size, sizeof(new_data_size));	memcpy((new_img+10), &new_data_offset, sizeof(new_data_offset));	memcpy((new_img+28), &new_bpp, sizeof(new_bpp));		//CHECKING VALUES:	/*	printf("img_height2: %d\n", img_height2);	printf("img_width2: %d\n", img_width2);	printf("new_height: %d\n", new_height);	printf("new_width: %d\n", new_width);	printf("new_bpp: %d\n", new_bpp);	printf("y_offset: %d\n", y_offset);	printf("new_data_offset: %d\n", new_data_offset);	printf("starting position in new image: %d\n", new_data_offset + ( (((new_width*new_bpp+31)/32)*4) * y_offset) + (((x_offset*new_bpp+31)/32)*4) );	printf("row size calc: %d\n", (((img_width2*new_bpp)+31)/32)*4);	*/	//unsigned char* new_img_pos = new_img + (new_data_offset+(x_offset*new_bpp)+(img_width1)^(y_offset*new_bpp));	unsigned char* new_img_pos;	if(y_offset < 0) {  //SINCE Y OFFSET IS NEGATIVE THE FIRST IMAGE STARTS AT THE TOP OF THE OFFEST		new_img_pos = new_img + new_data_offset + ( (((new_width*new_bpp+31)/32)*4) * (y_offset * -1));	}	else {		new_img_pos = new_img + new_data_offset;	}	unsigned char* inImage1 = img_data1 + data_offset1;	unsigned char* inImage2 = img_data2 + data_offset2;	//COPYING THE FIRST IMAGE INTO THE NEW IMAGE	///*	for (int a = 1; a<img_height1; a++) { 					memcpy(new_img_pos, inImage1, (((img_width1*new_bpp)+31)/32)*4);		inImage1 += (((img_width1*new_bpp)+31)/32)*4;		new_img_pos += ((((new_width*new_bpp)+31)/32)*4 );	}	//*/	if(y_offset < 0) {  //SINCE Y OFFSET IS NEGATIVE THE SECOND IMAGE STARTS AT THE FIRST ROW		new_img_pos = new_img + new_data_offset + (((x_offset*new_bpp+31)/32)*4);	}	else {		new_img_pos = new_img + new_data_offset +  ( (((new_width*new_bpp+31)/32)*4) * y_offset) + (((x_offset*new_bpp+31)/32)*4);	}	//COPYING IN THE SECOND IMAGE	for (int y = 1; y<img_height2; y++) { 					memcpy(new_img_pos, inImage2, (((img_width2*new_bpp)+31)/32)*4);		inImage2 += (((img_width2*new_bpp)+31)/32)*4;		new_img_pos += ((((new_width*new_bpp)+31)/32)*4 );	}	//WRITING DATA TO NEW BMP FILE:	FILE *newCollage;   	newCollage = fopen(bmp_result, "wb");    	fwrite(new_img, 1, new_data_size, newCollage);    	fclose(newCollage);	bmp_close( &img_data1 );	bmp_close( &img_data2 );  	return 0;}                  